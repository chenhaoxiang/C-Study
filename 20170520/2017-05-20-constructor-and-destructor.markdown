---
layout: post
title: "【C++】C++构造函数和析构函数"
date: 2017-05-20 13:38:54 +0800
comments: true
categories: C++
tags: [C++, basis]
keyword: 陈浩翔, 谙忆, C++, C++构造函数和析构函数
description: 
---

C++提供构造函数来处理对象的初始化。  
构造函数是一种特殊的成员函数，不需要用户来调用，定义对象时被自动执行。  
构造函数名字与类名相同，无返回类型(void也不能有哦)。

可以由用户自己定义实现，根据需要设计对数据成员进行初始化

<!-- more -->
----------

用上个例子来继续写代码进去  
CTime为类名

#无参数的构造函数：
在.h文件中进行声明：  
CTime();  
在.cpp文件中进行实现：  
```
CTime::CTime(){
	m_hour = 0;
	m_minute = 0;
	m_second = 0;
}
```
定义对象:  
CTime time;  
构造函数不需要我们去调用，定义一个对象的时候，会自动的去调用一个默认的无参构造函数。内部没有其他任何动作！
一般在构造函数中进行数据的初始化，当然，你还可以进行其他操作。  

如果你没写构造函数，在定义一个对象的时候，会自动生成调用一个空构造函数。  

#带参数的构造函数
在.h文件中进行声明：   
CTime(int hour,int minute,int second);

在.cpp文件中进行实现：    
```
CTime::CTime(int hour, int minute, int second){
	m_hour = hour;
	m_minute = minute;
	m_second = second;
}
```
定义对象:  
```
CTime time(10,50,20);
```

在一个类中可以有多个构造函数，函数名相同，参数不同，构造函数是可以重载的！

如果你有了其他面向对象语言的基础！前面这些章节都会很容易学的。

可以在声明的时候，给参数一个默认的值：  
```
CTime(int hour,int minute,int second = 0);  
```

在调用的时候，可以只传2个值，这个时候的second就会使用默认的值0；  

但是注意：
不能这么写  
```
CTime(int hour,int minute =0,int second);   
``` 
上面的写法是错误的！
也就是说，如果你在某个参数给了默认值，则排在它后面的参数你都需要给上默认值才行！

也不能给构造函数的每个参数都给上默认值  
```
CTime(int hour=0,int minute=0,int second=0);   
```
这样会引起歧义！！！  

#析构函数

也是C++中的一个成员函数。  
析构函数的作用和构造函数相反。  
命名规则与类名相同，但是需要在类名前加上"~"符号。  

~在C++中是取反运算符。  

析构函数一般式执行对象的清理工作。
当对象的生命周期结束之后，会自动调用析构函数。   
 
析构函数的作用不是删除对象，而是说，在对象撤销它所占用的内存之前做一些清理工作，清理之后，这个对象的内存可以被分配给其他对象使用。

在设计类的时候，都会给类提供一个析构函数。

构造函数和析构函数都是可以由用户来定义的，但是调用，都是可以由程序来自动调用的。

构造函数是在定义一个对象的时候执行的，而析构函数是在对象生命周期结束之后，自动执行析构函数。     

析构函数没有返回值和参数！    

注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。


析构函数的作用并不仅限于释放资源，还可以执行用户自己定义的一些操作，比如输出一些信息等。  

声明析构函数： 
```C++ 声明析构函数 
~CTime();  
```
定义析构函数：  
```C++ 定义析构函数
CTime::~CTime(){
	std::cout << "析构函数被执行了..." << std::endl;
}
```

析构函数的执行顺序和构造函数的执行顺序是相反的！  

也就是最先被定义的对象，最后被执行析构函数！  

用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。构造函数和析构函数对于类来说是不可或缺的！

在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。

new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。

#源代码下载地址：
<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/C-Study/tree/master/20170520/test3' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。 
欢迎转载，分享是进步的源泉。
<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>
